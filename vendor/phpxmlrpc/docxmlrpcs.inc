<?php
/**
 * Self-documenting extension to the PHP-XMLRPC server
 *
 * @author Gaetano Giunta
 * @version $Id: docxmlrpcs.inc,v 1.4 2006/05/14 18:03:41 ggiunta Exp $
 * @copyright (c) 2005 G. Giunta
 *
 * @todo use some AJAX magic to implement xmlrpc calls to test/debug methods
 *       without feeding to user the raw xml
 * @todo add some i18n support
 * @todo add a sane way to have a set of hhtp headers to be sent along with every
 *       type of generated documentation (eg. content-type)
 **/

	// requires: xmlrpc.inc, xmlrpcs.inc (version 2.0RC3 or later)

	/**
	* Extends the base xmlrpc server with the capability to generate documentation
	* about the exposed xmlrpc methods.
	* It will take advantage of a new memeber in the dispatch map: signature_docs
	* it is expected to be an array with the same number of memebers as signature,
	* but containing a short description for every parameter.
	*/
	class documenting_xmlrpc_server extends xmlrpc_server
	{
		/// default format for generated documentation: either wsdl or html
		var $default_doctype = 'html';
		var $default_doclang = 'en';
		var $supported_langs = array('en');
		var $supported_doctypes = array('html', 'wsdl');

		/**
		* Override xmlrpc_server service method:
		*   in case of GET requests show docs about implemented methods;
		*   in case of POST received by a form, we use the methodCall input value
		*   as if it had been sent with a tex/xml mimetype
		* @param string $data    request data to be parsed, null by default
		* @param string $doctype type of documentation to generate: html, wsdl, etc... If empty, use class default
		*/
		function service($data=null, $doctype='')
		{
			if($_SERVER['REQUEST_METHOD'] != 'POST')
			{
				if ($doctype == '' || !in_array($doctype, $this->supported_doctypes))
				{
					$doctype = $this->default_doctype;
				}
				// language decoding
				if (isset($_GET['lang']) && in_array(strtolower($_GET['lang']), $this->supported_langs))
				{
				    $lang = strtolower($_GET['lang']);
				}
				else
				{
				    $lang = $this->default_doclang;
				}

				print generateDocs($this, $doctype, $lang);
			}
			else
			{
				// we break the xmlrpc spec here, and answer to POST requests
				// that have been sent via a standard html form, such as the
				// one that is part of self-generated docs
				if(isset($_SERVER['CONTENT_TYPE'])
					&& $_SERVER['CONTENT_TYPE'] == 'application/x-www-form-urlencoded'
					&& isset($_POST['methodCall']))
				{
					parent::service($_POST['methodCall']);
				}
				else
				{
					parent::service($data);
				}
			}
		}

	}

	/**
	* Generate the documentation about methods exposed by a given server.
	* Note that it will NOT html-escape the user provided documentantation (ie. risky).
	* @param xmlrpcserver $server
	* @param string $doctype type of documentation to generate: html (default), wsdl, etc...
	* @param string $lang language for docs
	* @return string
	*
	* @todo add support for i18n of generated user-readable docs (eg html)
	*/
	function generateDocs($server, $doctype='html', $lang='en')
	{
		$payload = '';
		switch ($doctype)
		{
			case 'wsdl':
				break;
			case 'html':
				//$i18n = $GLOBALS['xmlrpcdoci18n'][$lang];
				$template = $GLOBALS['xmlrpcdocparts']['html'];
				// in case we have to send custom http headers, do it
				// removed from here, since we only return the payload now...
				//foreach ($template['httpheaders'] as $header)
				//	header($header);

				// method name decoding: is uer seeking info about a single method?
				if (isset($_GET['methodName']))
				{
					$payload .= xmlrpc_smarty($template['docheader'], array('lang' => $lang, 'title' => 'Method '.$_GET['methodName']));
					if ($server->allow_system_funcs)
					{
						$methods = array_merge($server->dmap, $GLOBALS['_xmlrpcs_dmap']);
					}
					else
					{
						$methods = $server->dmap;
					}
					if (!array_key_exists($_GET['methodName'], $methods))
					{
						$payload .= xmlrpc_smarty($template['methodheader'], array('method' => $_GET['methodName'], 'desc' => ''));
						$payload .= xmlrpc_smarty($template['methodnotfound'], array('method' => $_GET['methodName']));
					}
					else
					{
						$payload .= xmlrpc_smarty($template['methodheader'], array('method' => $_GET['methodName'], 'desc' => @$methods[$_GET['methodName']]['docstring']));
						//$payload .= xmlrpc_smarty($template['methodfound']);
						for ($i = 0; $i < count($methods[$_GET['methodName']]['signature']); $i++)
						{
							$val = $methods[$_GET['methodName']]['signature'][$i];
							// NEW: signature_docs array, MIGHT be present - or not...
							$doc = @$methods[$_GET['methodName']]['signature_docs'][$i];
							if (!is_array($doc) || !count($doc))
							{
								$doc = array_fill(0, count($val), '');
							}
							$payload .= xmlrpc_smarty($template['sigheader'], array('signum' => $i+1));
							$out = array_shift($val);
							$outdoc = array_shift($doc);
							for ($j = 0; $j < count($val); $j++)
							{
								$payload .= xmlrpc_smarty($template['sigparam'], array('paramtype' => $val[$j], 'paramdesc' => @$doc[$j]));
							}
							$payload .= xmlrpc_smarty($template['sigfooter'], array('outtype' => $out, 'outdesc' => $outdoc, 'method' => $_GET['methodName']));
						}
						$payload .= xmlrpc_smarty($template['methodfooter'], array('method' => $_GET['methodName']));
					}
				}
				else
				{
					// complete api info
					$payload .= xmlrpc_smarty($template['docheader'], array('lang' => $lang, 'title' => 'API Index'));
					$payload .= xmlrpc_smarty($template['apiheader']);
					foreach($server->dmap as $key => $val)
					{
						$payload .= xmlrpc_smarty($template['apimethod'], array('method' => $key, 'desc' => @$val['docstring']));
					}
					if($server->allow_system_funcs)
					{
						foreach($GLOBALS['_xmlrpcs_dmap'] as $key => $val)
						{
							$payload .= xmlrpc_smarty($template['apimethod'], array('method' => $key, 'desc' => @$val['docstring']));
						}
					}
					$payload .= xmlrpc_smarty($template['apifooter']);
				}

				$payload .= xmlrpc_smarty($template['docfooter']);

		}
		return $payload;
	}

	/**
	* Dumb (dumb dumb) smarty-like template system
	* @param string $template the template text, using {$var} syntax for substitution
	* @param array $params array of variables to be substituted in template, based on array key
	*
	* @todo introduce support for multilanguage directly here
	* @todo introduce support for nested arrays, so we can coalesce templates
	*/
	function xmlrpc_smarty($template, $params=array())
	{
		foreach ($params as $key => $val)
		{
			$template = str_replace("{\$$key}", $val, $template);
		}
		return $template;
	}

	/**
	* Templates used for building docs
	* The charset is assumed to be ISO-8859-1 for every generated html. Take care
	*/
	$GLOBALS['xmlrpcdocparts'] = array(
		'html' => array(

//'httpheaders' => array(),

'docheader' => '<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="{$lang}" lang="{$lang}">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta http-equiv="Content-Script-Type" content="text-javascript" />
<meta name="generator" content="'.$GLOBALS['xmlrpcName'].'" />
<style>
/**
 * CSS stylesheet for HTML documentation of xmlrpc methods.
 *   original style copied from XINS project (http://xins.sourceforge.net),
 *   from Ernst de Haan and Chris Gilbride
 *
 * @author Gaetano Giunta
 * @version $Id: docxmlrpcs.css,v 1.1 2005/12/01 14:46:29 ggiunta Exp $
 * @copyright (c) 2005 G. Giunta
 **/

body {
	font-family: sans-serif;
	color: #000000;
	background-color: #ffffff;
}

h1 {
	font-family: serif;
	color: #000000;
	font-size: 150%;
	text-align: left;
}

h2 {
	font-family: serif;
	color: #000000;
	font-size: 120%;
	text-align: left;
	border-width: 1pt 0pt 0pt 0pt;
	border-style: solid;
	border-color: #8888dd;
}

h3 {
	font-family: serif;
	font-size: 110%
}

table tr td {
	vertical-align: top;
}

table tr th {
	vertical-align: top;
}

table.headerlinks {
	width: 100%;
	border-collapse: collapse;
}

table.headerlinks tr td {
	padding: 2pt;
	margin: 0pt;
	font-variant: small-caps;
	background-color: #ddddff;
	border-width: 0pt 0pt 1pt 0pt;
	border-style: solid;
	border-color: #8888dd;
}

table.headerlinks tr td.prevnext {
	text-align: right;
}

.footer {
	margin-top: 16pt;
	border-width: 1pt 0pt 0pt 0pt;
	border-style: solid;
	border-color: #8888dd;
	font-size: 70%;
	font-style: italic;
	text-align: right;
}

table.metadata {
	left: 0pt;
	margin: 8pt 0pt 0pt 0pt;
	border-collapse: collapse;
}

table.metadata tr td.key {
	font-weight: bold;
	padding: 0pt 4pt 0pt 0pt;
}

table.metadata tr td.value {
	padding: 0pt;
}

table.parameters {
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: fixed;
	table-layout: auto;
	width: 100%;
}

table.parameters tr th {
	color: #ffffff;
	background-color: #8888dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
}

table.parameters tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.parameters tr td.value {
	font-family: monospace;
	font-size: 90%;
}

table.parameters tr td.name {
	font-family: monospace;
	font-size: 90%;
}

table.parameters tr td.required {
	/* font-variant: small-caps; */
}

table.inputparameters {
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: auto;
	width: 95%;
}

table.inputparameters tr th {
	color: #ffffff;
	background-color: #8888dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
}

table.inputparameters tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.inputparameters tr td.value {
	font-family: monospace;
	font-size: 90%;
}

table.inputparameters tr td.name {
	font-family: monospace;
	font-size: 90%;
}

table.inputparameters tr td.required {
	/* font-variant: small-caps; */
}

table.outputparameters {
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: auto;
	width: 95%;
}

table.outputparameters tr th {
	color: #ffffff;
	background-color: #8888dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
}

table.outputparameters tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.outputparameters tr td.value {
	font-family: monospace;
	font-size: 90%;
}

table.outputparameters tr td.name {
	font-family: monospace;
	font-size: 90%;
}

table.outputparameters tr td.required {
	/* font-variant: small-caps; */
}

table.resultcodes {
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: auto;
	width: 95%;
}

table.resultcodes tr th {
	color: #ffffff;
	background-color: #7777dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
}

table.resultcodes tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.resultcodes tr td.value {
	font-family: monospace;
	font-size: 90%;
}

table.resultcodes tr.default td.value {
	font-style: italic;
}

table.resultcodes tr td.name {
	font-family: monospace;
	font-size: 90%;
}

table.resultcodes tr td.required {
	/* font-variant: small-caps; */
}

table.element_details {
	width: 100%;
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: auto;
	width: 95%;
}

table.element_details tr th {
	color: #ffffff;
	background-color: #8888dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
	text-align: left;
	width: 160px;
}

table.element_details tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.example {
	border: none;
	border-collapse: collapse;
	table-layout: auto;
	width: 95%;
}

table.example tr th {
	background-color: #ddddff;
	text-align: left;
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.example tr td {
	background-color: #ddddff;
	text-align: left;
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.example tr td.header {
	text-align: left;
	border: none;
	padding: 2pt;
	background-color: #ffffff;
}

.xml {
    font-family: monospace;
    font-size: 90%;
	white-space: pre;
}

.xml .decl {
	font-weight: bold;
	color: #008800;
}

.xml .decl .elem .name {
	font-weight: bold;
	color: #008800;
}

.xml .elem .name {
	font-weight: bold;
	color: #000088;
}

.xml .pcdata {
	font-style: italic;
}

.xml .elem .attr .name {
	font-weight: normal;
	color: #000088;
}

.url {
    font-family: monospace;
    font-size: 90%;
	white-space: pre;
}

.url .functionparam .name {
	color: #880000;
	font-weight: bold
}

.url .functionparam .value {
	color: #880000;
	font-weight: bold
}

.url .param .name {
	color: #000088;
	font-weight: bold
}

.url .param .value {
	color: #008800;
	font-weight: bold
}

blockquote {
	margin-top: 10pt;
	margin-bottom: 10pt;
}

pre {
    font-family: monospace;
    font-size: 90%;
}

a:hover {
	background-color: #ddddff;
	text-decoration: underline;
}

a {
	color: #0000bb;
	text-decoration: none;
}

a:visited {
	color: #0000bb;
	text-decoration: none;
}

a img {
	border-style: none;
}

.disabled {
	color: #888888;
}

.active {
	color: #888888;
	font-weight: bold;
}

table.apilist {
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: fixed;
	table-layout: auto;
	width: 100%;
}

table.apilist tr th {
	color: #ffffff;
	background-color: #8888dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
	text-align: left;
}

table.apilist tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.functionlist {
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: fixed;
	table-layout: auto;
	width: 100%;
}

table.functionlist tr th {
	color: #ffffff;
	background-color: #8888dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
	text-align: left;
}

table.functionlist tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

table.typelist {
	border: none;
	background-color: #ddddff;
	border-collapse: collapse;
	table-layout: fixed;
	table-layout: auto;
	width: 100%;
}

table.typelist tr th {
	color: #ffffff;
	background-color: #8888dd;
	border: solid 1px #8888dd;
	padding: 2pt;
	font-weight: bold;
	text-align: left;
}

table.typelist tr td {
	border: solid 1px #8888dd;
	padding: 2pt;
}

input {
	border: 1px #8888dd solid;
	font-family: sans-serif;
	font-size: 9pt;
	background-color: #ffffff;
}

input.required {
	border: 2px #8888dd solid;
}

input[name=\'submit\'] {
	margin-top: 5px;
	text-align: center;
	font-weight: bold;
	cursor: hand;
	background-color: #eeeeff;
}

select {
	border: 1px #8888dd solid;
	font-family: sans-serif;
	font-size: 9pt;
	background-color: #ffffff;
}

select.required {
	border: 2px #8888dd solid;
}

td.status {
	font-variant: small-caps;
}

.broken_freeze {
	color: #ff4444;
	font-weight: bold;
}

div.broken_freeze {
	border: dashed 1px #ff4444;
	margin-top: 1em;
	margin-bottom: 1.5em;
	padding: 1em;
}
</style>
<title>{$title}</title>
</head>
<body>',

'docfooter' => '
<div class="footer">Generated using PHP-XMLRPC '.$GLOBALS['xmlrpcVersion'].'</div>
</body></html>',

'apiheader' => '
<h1>API index</h1>
<p>This server defines the following API specification:</p>
<table class="apilist">
<tr><th>Method</th><th>Description</th></tr>',

'apimethod' => '
<tr><td><a href="?methodName={$method}">{$method}</a></td><td>{$desc}</td></tr>',

'apifooter' => '
</table>',

'methodheader' => '
<h1>Method <em>{$method}</em></h1>
<div>{$desc}</div>',

'methodnotfound' => '
<h3>The method {$method} is not part of the API of this server</h3>
',

'sigheader' => '
<h2>Signature {$signum}</h2>
<blockquote>
<h3>Input parameters</h3>
<table class="inputparameters">
<tr><th>Type</th><th>Description</th></tr>',

'sigparam' => '
<tr><td>{$paramtype}</td><td>{$paramdesc}</td></tr>',

'sigfooter' => '
</table>
<h3>Output parameter</h3>
<table class="inputparameters">
<tr><th>Type</th><th>Description</th></tr>
<tr><td>{$outtype}</td><td>{$outdesc}</td></tr>
</table>
</blockquote>',

'methodfooter' => '
<h2>Test method call</h2>
<p>Complete by hand the form below inserting the needed parameters to call this method.<br/>
For a string param use e.g. <pre>&lt;param&gt;&lt;value&gt;&lt;string&gt;Hello&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;</pre></p>
<form action="" method="post"><p>
<textarea name="methodCall" rows="5" cols="80">
&lt;methodCall&gt;&lt;methodName&gt;{$method}&lt;/methodName&gt;
&lt;params&gt;
&lt;/params&gt;
&lt;/methodCall&gt;
</textarea><br/>
<input type="submit" value="Test"/>
</p></form>'
	    ),

		'wsdl' => array(
		)
	);

/*
	/// internationalization of docs templates
	$GLOBALS['xmlrpcdoci18n'] = array(
		'en' => array (
			'apiindex' => 'API Index'
		)
	);
*/
?>
